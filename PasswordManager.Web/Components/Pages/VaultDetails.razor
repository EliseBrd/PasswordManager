@page "/vault/{VaultId}"
@using PasswordManager.Web.Components.Vault
@using PasswordManager.Web.Services
@using PasswordManager.Dto.Vault.Requests
@using PasswordManager.Dto.Vault.Responses
@using System.Text.Json
@inject VaultService VaultService
@inject IJSRuntime JSRuntime

<PageTitle>Vault - @(vault?.Name ?? "...")</PageTitle>

@if (vault == null)
{
    <p>Chargement...</p>
}
else if (!isUnlocked)
{
    <div class="unlock-vault-form">
        <h3>Déverrouiller le coffre "@vault.Name"</h3>
        <input type="password" @bind="masterPassword" placeholder="Mot de passe du coffre" />
        <button @onclick="UnlockVault">Déverrouiller</button>
        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <p class="error-message">@errorMessage</p>
        }
    </div>
}
else
{
    <h1 class="titleHome">@vault.Name</h1>
    <button @onclick="() => showCreateForm = !showCreateForm">Ajouter une entrée</button>

    @if (showCreateForm)
    {
        <div class="create-entry-form">
            <h3>Nouvelle entrée</h3>
            <input @bind="newEntry.Title" placeholder="Titre" />
            <input @bind="newEntry.Username" placeholder="Nom d'utilisateur" />
            <input @bind="newEntry.Password" placeholder="Mot de passe" />
            <button @onclick="CreateEntry">Enregistrer</button>
        </div>
    }

    <div class="vaultEntries">
        @foreach (var entry in decryptedEntries)
        {
            <VaultEntry Title="@entry.Title"
                        Username="@entry.Username"
                        Password="@entry.Password"
                        OnShowPassword="@(() => ShowPassword(entry))"
                        Category=""
                        OnDelete="@(() => DeleteEntry(entry.Id))" />
        }
    </div>
}


<button class="btn btn-primary"
        @onclick="() => isModalOpen = true">
    <i class="fa-solid fa-plus"></i>
    Ajouter une entrée
</button>

<CreateVaultEntryModal IsOpen="@isModalOpen"
                        IsOpenChanged="@(v => isModalOpen = v)"
                        OnSave="CreateEntry" />


@code {
    [Parameter]
    public string VaultId { get; set; } = "";

    private VaultDetailsResponse? vault;
    private string masterPassword = "";
    private bool isUnlocked = false;
    private string errorMessage = "";
    private string decryptedVaultKey = ""; // Store the decrypted key here

    private List<DecryptedVaultEntry> decryptedEntries = new();
    
    private bool showCreateForm = false;
    private DecryptedVaultEntry newEntry = new();

    protected override async Task OnInitializedAsync()
    {
        try
        {
            vault = await VaultService.GetVaultDetailsAsync(VaultId);
        }
        catch (Exception ex)
        {
            errorMessage = "Impossible de charger les détails du coffre.";
        }
    }

    private async Task UnlockVault()
    {
        if (vault == null || string.IsNullOrWhiteSpace(masterPassword))
        {
            errorMessage = "Veuillez entrer le mot de passe.";
            return;
        }

        try
        {
            decryptedVaultKey = await JSRuntime.InvokeAsync<string>("cryptoFunctions.deriveKeyAndDecrypt", masterPassword, vault.MasterSalt, vault.EncryptedKey);

            foreach (var entryDto in vault.Entries)
            {
                var decryptedData = await JSRuntime.InvokeAsync<string>("cryptoFunctions.decryptData", decryptedVaultKey, entryDto.EncryptedData);
                var entryDetails = JsonSerializer.Deserialize<DecryptedVaultEntry>(decryptedData, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                if (entryDetails != null)
                {
                    entryDetails.Id = int.Parse(entryDto.Identifier); // Keep track of the real ID
                    decryptedEntries.Add(entryDetails);
                }
            }
            isUnlocked = true;
            errorMessage = "";
        }
        catch (Exception)
        {
            errorMessage = "Mot de passe incorrect ou erreur de déchiffrement.";
        }
    }

    private async Task CreateEntry()
    {
        if (string.IsNullOrWhiteSpace(newEntry.Title)) return;

        // Create a version of the entry without the password for EncryptedData
        var dataToEncrypt = new { newEntry.Title, newEntry.Username };
        var jsonData = JsonSerializer.Serialize(dataToEncrypt);
        var encryptedData = await JSRuntime.InvokeAsync<string>("cryptoFunctions.encryptData", decryptedVaultKey, jsonData);

        // Encrypt the password separately
        var encryptedPassword = await JSRuntime.InvokeAsync<string>("cryptoFunctions.encryptData", decryptedVaultKey, newEntry.Password);

        var request = new CreateVaultEntryRequest
        {
            VaultIdentifier = VaultId,
            EncryptedData = encryptedData,
            EncryptedPassword = encryptedPassword
        };

        await VaultService.CreateVaultEntryAsync(request);

        // Refresh UI (simplified)
        decryptedEntries.Add(newEntry);
        newEntry = new();
        showCreateForm = false;
    }

    private async Task ShowPassword(DecryptedVaultEntry entry)
    {
        // If password is not already revealed
        if (string.IsNullOrEmpty(entry.Password))
        {
            var encryptedPassword = await VaultService.GetVaultEntryPasswordAsync(entry.Id);
            if (encryptedPassword != null)
            {
                entry.Password = await JSRuntime.InvokeAsync<string>("cryptoFunctions.decryptData", decryptedVaultKey, encryptedPassword);
                StateHasChanged(); // Refresh the UI to show the password
            }
        }
    }

    private void DeleteEntry(int id)
    {
        // To be implemented
    }

    public class DecryptedVaultEntry
    {
        public int Id { get; set; }
        public string Title { get; set; } = "";
        public string Username { get; set; } = "";
        public string Password { get; set; } = ""; // Will be filled on demand
    }
}
